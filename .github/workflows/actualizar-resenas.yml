name: Actualizaci√≥n Diaria de Rese√±as

on:
  schedule:
    # Ejecutar todos los d√≠as a las 22:00 HS Argentina (01:00 UTC)
    - cron: '0 1 * * *'
  workflow_dispatch:
    inputs:
      full_regeneration:
        description: 'Regeneraci√≥n COMPLETA de embeddings (costoso)'
        required: false
        type: boolean
        default: false
      resume:
        description: 'RESUMIR ejecuci√≥n fallida (saltar ya procesados)'
        required: false
        type: boolean
        default: false

jobs:
  monitor-growth:
    runs-on: ubuntu-latest
    timeout-minutes: 320
    
    steps:
      - name: Checkout c√≥digo
        uses: actions/checkout@v4
      
      - name: Configurar Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'
      
      - name: Instalar Chrome
        uses: browser-actions/setup-chrome@v1
        with:
          chrome-version: stable
      
      - name: Instalar dependencias
        run: |
          pip install selenium webdriver-manager psycopg2-binary requests beautifulsoup4 pandas langchain-openai langchain-postgres sqlalchemy
      
      - name: Ejecutar Monitor
        id: monitor
        # Solo correr el monitor si NO es una regeneraci√≥n completa forzada
        if: github.event.inputs.full_regeneration != 'true'
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
        run: |
          python monitor_reviews.py 2>&1 | tee run.log
          
          # L√≥gica original de outputs
          if grep -q "CONTINUE_NEEDED" run.log; then
            echo "continue=true" >> $GITHUB_OUTPUT
          else
            echo "continue=false" >> $GITHUB_OUTPUT
          fi
          
          if grep -q "Rese√±as nuevas: [1-9]" run.log; then
            echo "has_new_reviews=true" >> $GITHUB_OUTPUT
          else
            echo "has_new_reviews=false" >> $GITHUB_OUTPUT
          fi


      
      - name: Regenerar Embeddings
        # Correr si:
        # 1. Es regeneraci√≥n forzada (full_regeneration == true)
        # 2. O si el monitor detect√≥ nuevas reviews (has_new_reviews == true)
        if: success() && (github.event.inputs.full_regeneration == 'true' || steps.monitor.outputs.has_new_reviews == 'true')
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          DEEPSEEK_API_KEY: ${{ secrets.DEEPSEEK_API_KEY }}
        run: |
          if [ "${{ github.event.inputs.full_regeneration }}" == "true" ]; then
            if [ "${{ github.event.inputs.resume }}" == "true" ]; then
              echo "üö® MODO FULL + RESUME: Continuando regeneraci√≥n..."
              python regenerate_embeddings.py --full --resume 2>&1 | tee -a run.log
            else
              echo "üö® MODO FULL ACTIVADO: Regenerando TODO..."
              python regenerate_embeddings.py --full 2>&1 | tee -a run.log
            fi
          else
            echo "üîÑ Regenerando embeddings inteligentemente (incremental)..."
            python regenerate_embeddings.py 2>&1 | tee -a run.log
          fi
      
      - name: Notificar a Discord
        if: always()
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
        run: |
          python -c "
          import os, requests, datetime, re
          
          webhook = os.environ.get('DISCORD_WEBHOOK_URL')
          if webhook:
              try:
                  # Valores por defecto
                  total_lugares = '?'
                  procesados = '?'
                  con_cambios = '?'
                  nuevas_reviews = '?'
                  tiempo = '?'
                  
                  # Parsear log para extraer estad√≠sticas
                  if os.path.exists('run.log'):
                      with open('run.log', 'r', encoding='utf-8', errors='ignore') as f:
                          log = f.read()
                          
                          # Buscar: Lugares a monitorear: X
                          m = re.search(r'Lugares a monitorear: (\d+)', log)
                          if m: total_lugares = m.group(1)
                          
                          # Buscar: Lugares procesados: X/Y
                          m = re.search(r'Lugares procesados: (\d+)/(\d+)', log)
                          if m: procesados = m.group(1)
                          
                          # Buscar: Lugares con cambios: X
                          m = re.search(r'Lugares con cambios: (\d+)', log)
                          if m: con_cambios = m.group(1)
                          
                          # Buscar: Rese√±as nuevas: X
                          m = re.search(r'Rese√±as nuevas: (\d+)', log)
                          if m: nuevas_reviews = m.group(1)
                          
                          # Buscar: Tiempo: X.X minutos
                          m = re.search(r'Tiempo: ([\d.]+) minutos', log)
                          if m: tiempo = m.group(1)
                  
                  msg = f'''üìä **Monitoreo Diario de Reviews**
          üìÖ {datetime.datetime.now().strftime('%d/%m/%Y %H:%M')}
          
          üìç **Lugares totales:** {total_lugares}
          ‚úÖ **Procesados:** {procesados}
          üîÑ **Con cambios:** {con_cambios}
          ‚≠ê **Rese√±as nuevas:** {nuevas_reviews}
          ‚è±Ô∏è **Tiempo:** {tiempo} min
          
          [Ver log completo en GitHub Actions]'''
                  
                  color = 0x2ecc71 if nuevas_reviews != '0' else 0x3498db  # Verde si hay nuevas
                  
                  requests.post(webhook, json={'embeds': [{'description': msg, 'color': color}]})
              except Exception as e:
                  print(f'Error enviando notif: {e}')
              except Exception as e:
                  print(f'Error enviando notif: {e}')
          "

      - name: Subir Log de Ejecuci√≥n
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: log-monitor-reviews
          path: run.log
      
      - name: Re-trigger si hay pendientes
        if: steps.monitor.outputs.continue == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "üîÑ Hay lugares pendientes, reiniciando workflow..."
          gh workflow run actualizar-resenas.yml
